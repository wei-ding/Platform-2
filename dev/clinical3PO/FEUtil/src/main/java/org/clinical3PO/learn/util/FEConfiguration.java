package org.clinical3PO.learn.util;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.TreeMap;


/**
 * Amounts to a collection of C3POFeatureExtractionStrategy objects (qv), keyed by
 * the name of the property they handle.
 * Each property can have multiple strategies in case we want e.g. both min and max for a property
 * This is the object that will initially be created from a configuration text file, later
 * from an ontology.
 * @author u0176876
 *
 */
public class FEConfiguration {
	private TreeMap<String,ArrayList<FEStrategyBase>> strategies;
	//private C3POFeatureExtractionStrategy defaultStrategy;

	/**
	 * the name of the required default property strategy (configuration can have multiple, must have at least one)
	 */
	public static final String defaultPropertyName = "*default*";

	/** 
	 * when looking up a class property handler, prepend this on the property name
	 * let's make it be weka-legal
	 */
	//	public static final String classPropertyPrefix = "classAttribute_";

	// Replacing with previous line to generate proper arff format
	public static final String classPropertyPrefix = "class";

	//little private class to handle line number/token pairs
	class CFECToken {
		public int lineNumber;
		public String token;

		public CFECToken(int ln, String t) {
			lineNumber = ln;
			token = t;
		}

		public String toString() {
			return token + "(" + lineNumber + ")";
		}
	}

	//little private class to describe a keyword/class/token span for some subset of the config file
	class CFECEntity {
		public int firstToken;
		public int lengthInTokens;
		public int offsetToContent;				//how many tokens were consumed with keyword, class name, open-curly - may vary among block types
		public String entityName;
		public String entityClass;

		public CFECEntity(int first, int len, int ofs, String name, String cls) {
			firstToken = first;
			lengthInTokens = len;
			offsetToContent = ofs;
			entityName =  name;
			entityClass = cls;
		}
	}


	public FEConfiguration() {
		//create an empty strategies tree - we'll accumulate onto it.
		strategies = new TreeMap<String, ArrayList<FEStrategyBase>>();
	}

	public boolean hasStrategyForProperty(String prop) {
		if(prop == null || strategies == null || !strategies.containsKey(prop)) {
			return false;
		}
		return true;
	}

	public ArrayList<FEStrategyBase> getStrategiesForProperty(String prop) throws Exception {
		if(prop == null) {
			//error message? exception?
			throw new Exception("Null property given to getStrategiesForProperty");
		}

		if(strategies == null) {
			throw new Exception("Null strategies list in getStrategiesForProperty (haven't read config file?)");
		}

		if(!strategies.containsKey(prop)) {
			//not an error - use default - now this is handled differently
			//should I warn?
			return strategies.get(defaultPropertyName);
		}

		return strategies.get(prop);
	}

	public boolean hasClassStrategyForProperty(String prop) {
		if(prop == null || strategies == null || !strategies.containsKey(classPropertyPrefix+prop)) {
			return false;
		}
		return true;
	}

	public FEStrategyBase getClassStrategyForProperty(String prop) throws Exception {
		if(prop == null) {
			//error message? exception?
			throw new Exception("Null property given to getClassStrategyForProperty");
		}

		if(strategies == null) {
			throw new Exception("Null strategies list in getClassStrategyForProperty (haven't read config file?)");
		}

		if(!strategies.containsKey(classPropertyPrefix+prop)) {
			throw new Exception("No class strategy exists for property " + prop);
		}

		//there should only be one of them, so return first element of the ArrayList returned.
		return strategies.get(classPropertyPrefix+prop).get(0);
	}

	// CONFIGURATION TEXT FILE PARSING UTILITY FUNCTIONS ================================================================================

	/**
	 * getDelimitedBlockLength takes an array of String tokens - possibly an entire extraction strategy file, possibly a 
	 * subsequence generated by this very
	 * function, and a startPos which is an index into it, assumed to be pointing just after a delimiter starting a block you want to
	 * extract. It returns the length of the subsequence that represents the block of text found up to and including the matching 
	 * closingDelimiter - which may include nested blocks.
	 * For instance: Say you have this string as text, tokenized by whitespace
	 * ---
	 * property gooboir org.clinical3PO.util.C3POFeatureExtractionDefaultStrategy {
	 *     binner org.clinical3PO.util.C3POFeatureExtractionFixedWidthBinner {
	 *         binWidth 3600.0
	 *     }
	 *     evaluator org.clinical3PO.util.C3POFeatureExtractionBasicEvaluator {
	 *         derivation mean
	 * 	       errorStrategy alwaysUnk 
	 *         emptyBinStrategy lastLegit
	 *         legitLow 0.0
	 *         legitHigh 300.0
	 *     }
	 * } 
	 * ---  
	 * and openingDelimiter is "{" and closingDelimiter is "}" and the startPos points just after that first open-curly. 
	 * The return from this would be the length of the substring that goes up to and including the matching },
	 * which is the one at the end of this snippet. So, it needs to recognize the opening delimiter "{" to recognize
	 * nesting. 
	 * LET'S KEEP THIS SIMPLE - delimiters and they always act like delimiters, no escapes or anything.
	 * might later change that and have string constants or \{ or whatever, but for now, it's like that.
	 * This is supposed to be a temporary thing anyway, the text file config.
	 * THIS IS ALL TOKEN-BASED and the index is into an array of strings. So I can just
	 * iterate over tokens the way I do now over chars and delimiters can be non-single-character and the
	 * burden for finding escaped stuff could be on the tokenizer below.
	 * @param text
	 * @param openingDelimiter
	 * @param closingDelimiter
	 * @param startPos
	 * @return subsequence length or -1 on error (no matching closing delimiter found)
	 */
	public static int getDelimitedBlockLength(ArrayList<CFECToken> tokens,String openingDelimiter,String closingDelimiter,int startPos) throws Exception {

		int nestingLevel = 0;
		int subseqLen = 0;

		//so: scan through string starting at startPos. Assumed to be starting right after an openingDelimiter,
		//so level gets bumped up one whenever we see an openingDelimiter and down one when we see a closingDelimiter.
		//if the nesting level goes to -1, we've found the matching closing delimiter!
		int j;
		for(j=startPos;j<tokens.size();j++) {
			//System.err.println("Examining token |" + tokens.get(j).token + "|");	//TODO RIP OUT EXTREMELY VERBOSE DEBUG
			if(tokens.get(j).token.equals(openingDelimiter)) {
				nestingLevel++;
				//System.err.println("Incrementing nesting level to " + nestingLevel);		//TODO RIP OUT VERBOSE
			}
			else if(tokens.get(j).token.equals(closingDelimiter)) {
				//yay, found matching closing delimiter! 
				nestingLevel--;
				//System.err.println("Decrementing nesting level to " + nestingLevel);		//TODO RIP OUT VERBOSE
				if(nestingLevel == -1) return subseqLen + 1;		//+1 to step over closing delimiter - remember we want the advance to point PAST it
			}

			subseqLen++;			
		}

		//if we got here, error: didn't find matching ending delimiter
		return -1;
	}

	/**
	 * helper function to read files
	 * from http://stackoverflow.com/questions/326390/how-to-create-a-java-string-from-the-contents-of-a-file
	 * only mine will put it all into one ws-delimited line and then split that into ws-delimited tokens.
	 * EACH TOKEN WILL CONSIST OF a CFECToken object
	 * also discard lines starting with # after ws 
	 */
	/* old version - let's make it so the tokens know what line they came from
	public static String[] tokenizeFile(File file) throws IOException {
		StringBuilder fileContents = new StringBuilder((int)file.length());
		Scanner scanner = new Scanner(file);
		//String lineSeparator = System.getProperty("line.separator");
		String theLine = null;
		try {
			while(scanner.hasNextLine()) {        
				theLine = scanner.nextLine().trim();
				//skip comments, which start with zero or more whitespace chars and then #
				if(!theLine.isEmpty() && !theLine.startsWith("#")) fileContents.append(theLine + " "); 		//was lineSeparator);
			}
			return fileContents.toString().trim().split("\\s+");
		} finally {
			scanner.close();
		}
	}	
	 */

	public ArrayList<CFECToken> tokenizeFile(File file) throws IOException {
		Scanner scanner = new Scanner(file);

		return tokenizeFile(scanner);
	}

	public ArrayList<CFECToken> tokenizeFile(Scanner scanner) throws IOException {
		ArrayList<CFECToken> tokArray = new ArrayList<CFECToken>(); 
		//String lineSeparator = System.getProperty("line.separator");
		String theLine = null;
		int lineNum = 1;
		try {
			while(scanner.hasNextLine()) {        
				theLine = scanner.nextLine().trim();
				//skip comments, which start with zero or more whitespace chars and then #
				if(!theLine.isEmpty() && !theLine.startsWith("#")) {
					String[] linetoks = theLine.split("\\s+");
					for(String tok:linetoks) {
						//SO NOW TOKENS ARE LINE NUMBER, SPACE, token.
						//THIS WORKS BC IT WAS WS DELIMITED
						tokArray.add(new CFECToken(lineNum,tok));
					}
				}
				lineNum++;
			}
			//return fileContents.toString().trim().split("\\s+");
			return tokArray;
		} finally {
			scanner.close();
		}
	}	


	// end CONFIGURATION TEXT FILE PARSING UTILITY FUNCTIONS ============================================================================


	/**
	 * generalized method to parse keyword + class name + {} block;
	 *  
	 * @param theTokens - entire config file token stream
	 * @param keyword - the keyword we're looking for ("property", "binner", "evaluator", etc.)
	 * @param getName - properties have a name after the keyword, other things may not; if this is true it'll fetch a name otherwise won't
	 * @param startpos - index into theTokens at which we expect to find the keyword + class name + {} block
	 * @param endpos - index into theTokens it shouldn't run past
	 * @return CFECEntity describing what was found
	 * @throws Exception
	 */

	public CFECEntity parseKeywordPlusClass(ArrayList<CFECToken> theTokens, String keyword, boolean getName, int startpos, int endpos) throws Exception {

		//System.err.println("entering parseKeywordPlusClass, startpos " + startpos + " endpos " + endpos);

		//so then: iterate over that and build our strategy list.
		String theName = null;
		String className = null;
		boolean done = false;
		CFECToken theToken = null;
		int j=startpos;
		int offsetToContent = -1;
		while(!done) {
			//this loop should have us in the state that we expect a "property" keyword, then a property name string as the
			//next token, then a strategy class name as the token after that, then a { } delimited block that describes the
			//strategy and which can be handed to its propname / String[] constructor
			//Actually token is now a little object
			//TODO: figure out a better way to eat tokens
			theToken = theTokens.get(j);
			if(theToken.token.equalsIgnoreCase(keyword)) {
				j++; //skip property keyword
				if(j < endpos) {
					if(getName) {
						theToken = theTokens.get(j);
						theName = theToken.token;			//memorize entity name if using one
						//System.err.println("Found entity name: " + theName);
						j++;	//skip property name 
					}
					if(j < endpos) {
						theToken = theTokens.get(j);
						className = theToken.token;		//memorize strategy class name
						//System.err.println("Found class name: " + className);
						j++;

						//now there should be a "{"
						if(j < endpos) {
							theToken = theTokens.get(j);
							if(theToken.token.equals("{")) {
								//System.err.println("Found { after entity class name");
								j++;		//eat {
								//record offset to content
								offsetToContent = j-startpos;

								int blocklen = getDelimitedBlockLength(theTokens, "{", "}", j); 
								if(blocklen != -1) {
									//TODO DO SOMETHING WITH IT!
									//System.err.println("Found delimited block length of " + blocklen + " tokens inside block for keyword " + keyword);

									//so - return to caller what we found; i.e., CFECEntity with entity name and classname,
									//block length = offset to token index at next keyword (or eof, in property's case) 
									//AFTER the offsetToContent; i.e. startpos + offsetToContent + blocklen should be the token after the enclosing }
									return new CFECEntity(startpos, blocklen, offsetToContent, theName, className);
								} else {
									throw new Exception("Failed to find {} delimited block starting after { on line " + theToken.lineNumber);
								}
							} else {
								throw new Exception("Expected { after entity class name, got \"" + theToken.token + "\", line " + theToken.lineNumber);
							}
						} else {
							throw new Exception("Unexpected end of file after entity class name, line " + theToken.lineNumber);
						}
					} else {
						throw new Exception("Unexpected end of block (case 1) keyword " + keyword);
					}
				} else {
					throw new Exception("Unexpected end of block (case 3) keyword " + keyword);
				}
			} else {
				throw new Exception("Expecting '" + keyword + "' keyword, got token \"" + theToken.token + "\", line " + theToken.lineNumber);
			}
		}

		System.err.println("Unexpected running out of file looking for keyword " + keyword);
		return null;			//I THINK IT SHOULDN'T GET HERE
	}


	/**
	 * sub-helper for parse: given a start and length for a subset of a token stream, turns it back into a string,
	 * appending a space in between each pair of tokens UNLESS their line numbers are different, in which case it appends a newline in between them.
	 * @param tokens
	 * @param startpos
	 * @param blocklen
	 * @return
	 */
	protected String makeStringFromTokenSubset(ArrayList<CFECToken> tokens, int startpos, int blocklen) throws Exception {
		StringBuffer buf = new StringBuffer();

		int prevline = -1;

		for(int j=0;j<blocklen;j++) {
			CFECToken tok = tokens.get(startpos+j);
			if(j!=0) {
				//before each token other than the first, append whitespace - space for tokens on the same
				//line as the previous, newline for different-line ones.
				//insert blank lines if there is more than one line difference bt the tokens.
				if(tok.lineNumber != prevline) {
					for(int k=0;k<tok.lineNumber-prevline;k++) buf.append(System.getProperty("line.separator"));
				}
				else buf.append(" ");
			}
			buf.append(tok.token);
			prevline = tok.lineNumber;
		}

		return buf.toString();
	}

	/**
	 * mechanism for using a binner, evaluator, or valuetype from another property's strategy
	 * TODO: CURRENTLY REQUIRES THAT THE PROPERTY'S STRATEGY ALREADY HAS BEEN PARSED AND THAT THERE IS ONLY ONE FOR IT.
	 * to allow for more will need ways to specify which
	 * @param keyword
	 * @param propname
	 * @return
	 */
	protected boolean useElementFrom(FEStrategyBase strat, String keyword, String propname) throws Exception {
		if(!strategies.containsKey(propname) || strategies.get(propname).size() != 1) {
			throw new Exception("Attempted to " + keyword + " on a property " + propname + " that has more or fewer than one strategy");
		}

		int index;		//looking forward to when we're able to do this with multi-strategy props
		index = 0;		//TODO: but for now, it's always the first (only) one.

		if(keyword.equalsIgnoreCase("usebinner")) {
			//mechanism to say that we'll use the binner from a previously-defined property strategy.
			strat.setBinner(strategies.get(propname).get(index).getBinner());
			strat.setUsesOtherPropertyBinner(true);
		} else if(keyword.equalsIgnoreCase("useevaluator")) {
			//mechanism to say that we'll use the evaluator from a previously-defined property strategy.
			strat.setEvaluator(strategies.get(propname).get(index).getEvaluator());
			strat.setUsesOtherPropertyEvaluator(true);
		} else if(keyword.equalsIgnoreCase("usevaluetype")) {
			//mechanism to say that we'll use the valuetype from a previously-defined property strategy.
			strat.setValueType(strategies.get(propname).get(index).getValueType());
			strat.setUsesOtherPropertyValueType(true);
		} else {
			throw new Exception("Unrecognized keyword \"" + keyword + "\" in useElementFrom");
		}

		return true;
	}

	/**
	 * sub-helper for parse - given 
	 * @param strat - strategy object being built, will be modified
	 * @param keyword - "binner", "evaluator", "valuetype", "usebinner", "useevaluator", "usevaluetype" - BE SURE TO MAINTAIN THIS FOR FURTHER TYPES
	 * @param className - name of the class to try to instantiate
	 * @param defBlock - definition block found in script file, will be handed to object's parse method
	 * @param startLine - line of script on which this def block starts, for error reporting.
	 * @return
	 */
	protected boolean addComponentToStrategy(FEStrategyBase strat, String keyword, String className, String defBlock, int startLine) throws Exception {
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//HERE IS ANOTHER PLACE WHERE THE KEYWORDS NEED TO BE MAINTAINED
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************
		//********************************************************************************************************************************************

		if(strat ==  null) {
			System.err.println("ERROR: addComponentToStrategy got null strategy object coming in");
			return false;
		}

		if(keyword.equalsIgnoreCase("binner")) {
			FEBinnerBase binner = (FEBinnerBase)Class.forName(className).newInstance();
			//TODO HERE CALL THE PARSING FUNCTION ON THE NEW OBJECT WITH DEFBLOCK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			if(binner.instantiateFrom(defBlock, startLine) == false) {
				System.err.println("ERROR: binner instantiateFrom() failed");
				return false;
			}
			strat.setBinner(binner);
			//System.err.println("---- successfully added a binner of type " + className + ": " + binner);
		} else if(keyword.equalsIgnoreCase("evaluator")) {
			FEEvaluatorBase evaluator = (FEEvaluatorBase)Class.forName(className).newInstance();
			if(evaluator.instantiateFrom(defBlock, startLine) == false) {
				System.err.println("ERROR: evaluator instantiateFrom() failed");
				return false;
			}
			strat.setEvaluator(evaluator);
			//System.err.println("---- successfully added an evaluator of type " + className + ": " + evaluator);
		} else if(keyword.equalsIgnoreCase("valuetype")) {
			FEValueBase valuetype = (FEValueBase)Class.forName(className).newInstance();
			if(valuetype.instantiateFrom(defBlock, startLine) == false) {
				System.err.println("ERROR: valuetype instantiateFrom() failed");
				return false;
			}
			strat.setValueType(valuetype);
			System.err.println("---- successfully added a valuetype of type " + className + ": " + valuetype);
		} else if(keyword.equalsIgnoreCase("usebinner") || 
				keyword.equalsIgnoreCase("useevaluator") ||
				keyword.equalsIgnoreCase("usevaluetype")) {

			//default property isn't allowed to do this
			if(strat.getPropertyName().equalsIgnoreCase(defaultPropertyName)) {
				throw new Exception("Default strategy (" + defaultPropertyName + ") not allowed to do " + keyword);
			}

			//mechanism to say that we'll use the binner/eval/valtype from a previously-defined property strategy.
			//eat a token - actually, 
			if(!useElementFrom(strat, keyword, defBlock)) {
				throw new Exception("Failed to " + keyword + " " + defBlock + " in property " + strat.getPropertyName());
			}
		} else {
			throw new Exception("Unrecognized property component keyword: \"" + keyword + "\"");
		}

		return true;
	}

	/**
	 * helper for parseFromTextConfigFile below - given the token stream, the starting position within it, and the number of tokens
	 * occupied by the binner/evaluator block, find the binner/evaluator subsets. 
	 * @param tokens
	 * @param startpos
	 * @param blocklen
	 * @param strat a Strategy object constructed by caller but without its binner/eval/etc filled in yet
	 * @return true (strat has the given binner/evaluator/valuetype/etc. filled in) or false on error
	 * @throws Exception
	 */
	protected boolean parseSinglePropertyBlock(ArrayList<CFECToken> tokens, int startpos, int blocklen, FEStrategyBase strat) throws Exception {

		//TODO: Figure out what to do here. At the beginning we should be pointing at either
		//a "binner" or "evaluator" or "valuetype" keyword, OR OTHER KEYWORD TBD LATER, followed by a class name, then there'll
		//be a definition block.

		int nextStart = startpos;
		boolean done = false;

		while(!done) {
			//FIRST TRY: just report what we got; peek at keyword, then we'll call parseKeywordPlusClass to fetch out the block
			String keyword = tokens.get(nextStart).token;
			//System.err.println("parseSinglePropertyBlock sees keyword: |" + keyword + "|");

			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//NOTE HERE IS WHERE THE PERMISSIBLE KEYWORD TYPES ARE LISTED - MAINTENANCE SPOT IF WE ADD MORE!
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			//********************************************************************************************************************************************
			if(keyword.equalsIgnoreCase("binner") ||
					keyword.equalsIgnoreCase("evaluator") ||
					keyword.equalsIgnoreCase("valuetype")) {

				//entities inside the property block don't have names like the properties themselves do, so getName param to this is false.
				CFECEntity ent = parseKeywordPlusClass(tokens, keyword, false, nextStart, blocklen);
				int subBlockExtent = ent.lengthInTokens;

				//System.err.println("Found a " + keyword + " block! Name " + ent.entityName + " class " + ent.entityClass + " start " + ent.firstToken + " offset to content " + ent.offsetToContent + " length " + ent.lengthInTokens);


				//TODO HERE'S WHERE TO TRY THE REFLECTION CREATE OF THE CLASS TYPE with the string make of the subset of the token stream allocated to it
				//TODO WRITE THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				//TODO it'll look *something* like this
				//int parsePropResult = parseSinglePropertyBlock(configTokens, nextStart+ent.offsetToContent, propertyExtent - ent.offsetToContent);
				//System.err.println("Attempting to instantiate " + ent.entityClass);
				try {
					Class.forName(ent.entityClass);
					//System.err.println("-- Class.forName(" + ent.entityClass + ") succeeded!");

					//now hand off and fill in the component for that entity
					//the string given is the token stream turned back into plain text, ws-delimited,
					//see makeStringFromTokenSubset above
					//uses lengthInTokens-1 because lengthInTokens includes the ending curly
					String defBlock = makeStringFromTokenSubset(tokens, nextStart+ent.offsetToContent, ent.lengthInTokens-1); 

					if(addComponentToStrategy(strat, keyword, ent.entityClass, defBlock, tokens.get(nextStart+ent.offsetToContent).lineNumber) == false) {
						throw new Exception ("Failed to add component of class " + ent.entityClass + " starting on line " + tokens.get(nextStart).lineNumber + " with def block |" + defBlock + "|");
					}

				} catch (ClassNotFoundException cnfe) {
					System.err.println("WARNING - unable to getClass() for class " + ent.entityClass);
					throw cnfe;			//TODO figure out what to do 
				}


				nextStart += ent.offsetToContent+subBlockExtent;
			} else if(keyword.equalsIgnoreCase("usebinner") ||
					keyword.equalsIgnoreCase("useevaluator") ||
					keyword.equalsIgnoreCase("usevaluetype")) {
				//eat the keyword
				nextStart++;
				// special case: def block is one token
				String defBlock = tokens.get(nextStart).token;

				//System.err.println("Found a " + keyword + " directive! From property " + defBlock);

				if(addComponentToStrategy(strat, keyword, null, defBlock, tokens.get(nextStart).lineNumber) == false) {
					throw new Exception ("Failed to " + keyword + " " + defBlock + " starting on line " + tokens.get(nextStart).lineNumber + " with def block |" + defBlock + "|");
				}

				//eat what the addComponent took; ASSUMING THAT ONLY EATS one token - if we have ways of accommodating multiple
				//strategies later, that could change
				nextStart++;
			} else {
				//cheat and have a } condition
				if(keyword.equals("}")) {
					//System.err.println("--found what is assumed to be property endcurly");
					done = true;
				} else {
					throw new Exception("Unrecognized keyword in property block, expecting binner, evaluator, or valuetype, got: \"" + keyword + "\"");
				}
			}
			//TODO VERIFY THIS END CONDITION - remember we also get the property block's endcurly, so knock off 1 token for that?
			if(nextStart >= (startpos+blocklen)-1) {
				done = true;
			}


		}

		return true; 
	}




	/**
	 * first implementation of feature extraction strategy configuration is to parse it from a 
	 * simple text file.
	 * File format is this: 
	 * # any line starting with # is a comment, no inline comments (must occupy their own line, can have whitespace ahead of the #
	 * 1 or more property blocks, which look like
	 * property <property name> <property class> <param block>
	 * where 
	 * property name is a string with no whitespace that 
	 * property class is a full package-and-class-name java class name which the parser will attempt to instantiate with reflection. 
	 * param block is enclosed in { } and contains definitions for the strategy, which may have nested {} blocks
	 * {} delimiters must be separated by whitespace from other things
	 * @param path
	 * @return
	 * @throws Exception
	 */
	//now called "accumulate" because they add onto existing strategies tree, so we can read
	//multiple config files.

	public boolean accumulateFromTextConfigFile(InputStream is, String classProperty) throws Exception {
		//so: read the entire file into memory, discarding comment lines (those that start with \s*#)
		//should I preserve \n? or just append everything into one giant line? Let's do it so that everything is
		//ws delimited - should work with one big line...? Let's just call a tokenizer that gives us all the non-commented
		//tokens in the file, according to whatever rules I want for tokenizing, initially really simple.

		ArrayList<CFECToken> configTokens = tokenizeFile(new Scanner(is));

		return accumulateFromTextConfigFile(configTokens, classProperty);
	}

	public boolean accumulateFromTextConfigFile(String path, String classProperty) throws Exception {

		//so: read the entire file into memory, discarding comment lines (those that start with \s*#)
		//should I preserve \n? or just append everything into one giant line? Let's do it so that everything is
		//ws delimited - should work with one big line...? Let's just call a tokenizer that gives us all the non-commented
		//tokens in the file, according to whatever rules I want for tokenizing, initially really simple.

		ArrayList<CFECToken> configTokens = tokenizeFile(new File(path));

		return accumulateFromTextConfigFile(configTokens, classProperty);
	}

	public boolean accumulateFromTextConfigFile(ArrayList<CFECToken> configTokensList, String classProperty) throws Exception {
		//was TreeMap<String,ArrayList<C3POFeatureExtractionStrategy>>
		//here's what we'll build here:
		//TreeMap<String,ArrayList<C3POFeatureExtractionStrategy>> propStrategies = new TreeMap<String,ArrayList<C3POFeatureExtractionStrategy>>();


		int nextStart = 0;

		//TODO WORK XONE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		//so. if we call parseKeywordPlusClass with "property" and an ending value of # tokens in the stream...
		//this will go in a loop
		boolean done = false;

		while(!done) {
			//now we allow either "property" or "class"
			String keyword = configTokensList.get(nextStart).token;
			//System.err.println("accumulateFromTextConfigFile sees keyword: |" + keyword + "|");			

			if(!keyword.equalsIgnoreCase("property") && !keyword.equalsIgnoreCase("class")) {
				throw new Exception("Expected either 'property' or 'class' keyword");
			}

			CFECEntity ent = parseKeywordPlusClass(configTokensList, keyword, true, nextStart, configTokensList.size());
			int propertyExtent = ent.lengthInTokens;

			System.err.println("Found a " + keyword + " block! Name " + ent.entityName + " class " + ent.entityClass + " start " + ent.firstToken + " offset to content " + ent.offsetToContent + " length " + ent.lengthInTokens);

			// HERE if the block is a class block and it's not for the property given on the command line, skip it.
			if(keyword.equalsIgnoreCase("class") && !ent.entityName.equals(classProperty)) {
				System.err.println("-- class block isn't for class property " + classProperty + ": skipping.");
			} else {

				// Here need to look ahead at the next token, which should be a binner or evaluator keyword or other keyword TBD.
				// then do another call to parseKeywordPlusClass to get its guts, and hand the guts over to an instance of the class
				// to be parsed
				// keep doing this until we reach the end of the property block.
				// - now handled by parseSinglePropertyBlock
				//HERE CONSTRUCT the strategy-based object given by ent.entityClass, if possible,
				//and parseSinglePropertyBlock will supply the binner, evaluator, valuetype, etc.
				//TODO IF I WANT TO LOOK AT PARTICULARS OF A CLASS see http://docs.oracle.com/javase/tutorial/reflect/class/classModifiers.html
				//might want to make a sanity-checker based on that program
				FEStrategyBase strat = null;

				//System.err.println("-- attempting to instantiate strategy class: " + ent.entityClass);
				Class.forName(ent.entityClass);

				//http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#newInstance%28%29
				//OK HERE GET AN ACTUAL INSTANCE!
				strat = (FEStrategyBase)Class.forName(ent.entityClass).newInstance();
				strat.setPropertyName(ent.entityName);

				//System.err.println("-- instantiation worked: " + strat);

				/* this is no longer true.
				//null out binner if it's a class we're doing - strategy may install a default one, which is ok for properties,
				//but unused for classes
				if(keyword.equalsIgnoreCase("class")) {
					strat.setBinner(null);
				}
				 */

				//fill in the components with parseSinglePropertyBlock
				//step over the keyword, class name, opencurly with the entity's offset to content (and subtract that from the max # tokens)
				//TODO maybe factor that in the entity's returned extent to make that less confusing? - that's now done
				if(parseSinglePropertyBlock(configTokensList, nextStart+ent.offsetToContent, nextStart+ent.offsetToContent+propertyExtent, strat)) {
					System.err.println("Successfully parsed property " + ent.entityName);
				}

				//sanity check: properties must have all of binner, evaluator, and valuetype; classes don't need a binner (warn if there is one)
				//also: there can only be one class strategy per property.
				//property name for class is classPropertyPrefix + property name
				//actually let's have it so that not having one amounts to usebinner/useevaluator/usevaluetype *default*
				//let's say that *default* must already have been defined for this to work
				//does this mean there can be only one default strategy?
				if(keyword.equalsIgnoreCase("property")) {
					if(strat.getBinner() == null) {
						//this is an error in default property
						if(strat.getPropertyName().equalsIgnoreCase(defaultPropertyName)) {
							throw new Exception("Default property (" + defaultPropertyName + ") has null binner");
						}
						if(!useElementFrom(strat, "usebinner", defaultPropertyName)) {
							throw new Exception("Property with null binner failed to use the one from " + defaultPropertyName);
						}
						System.err.println("Null binner in strategy for property " + ent.entityName + " - will use binner from " + defaultPropertyName);
					}
					if(strat.getEvaluator() == null) {
						//this is an error in default property
						if(strat.getPropertyName().equalsIgnoreCase(defaultPropertyName)) {
							throw new Exception("Default property (" + defaultPropertyName + ") has null evaluator");
						}
						if(!useElementFrom(strat, "useevaluator", defaultPropertyName)) {
							throw new Exception("Property with null evaluator failed to use the one from " + defaultPropertyName);
						}
						System.err.println("Null evaluator in strategy for property " + ent.entityName + " - will use evaluator " + defaultPropertyName);
					}
					if(strat.getValueType() == null) {
						//this is an error in default property
						if(strat.getPropertyName().equalsIgnoreCase(defaultPropertyName)) {
							throw new Exception("Default property (" + defaultPropertyName + ") has null valuetype");
						}
						if(!useElementFrom(strat, "usevaluetype", defaultPropertyName)) {
							throw new Exception("Property with null valuetype failed to use the one from " + defaultPropertyName);
						}
						System.err.println("Null valuetype in strategy for property " + ent.entityName + " - will use valuetype " + defaultPropertyName);
					}

					//HERE add this to our map of string -> C3POFeatureExtractionStrategy. YAY
					//actually each property can have multiple.
					//so if there isn't a ArrayList full of them yet, create one.
					if(!strategies.containsKey(ent.entityName)) {
						strategies.put(ent.entityName, new ArrayList<FEStrategyBase>());
					}
					//then add our new one to the ArrayList.
					ArrayList<FEStrategyBase> stratvec = strategies.get(ent.entityName);
					stratvec.add(strat);
					strategies.put(ent.entityName, stratvec);
				} else if(keyword.equalsIgnoreCase("class")) {
					//class property handled a bit different - there can be only one (i.e., we can't have multiple strategies for a single class property.)
					//(it's ok to have multiple class properties defined, but only one will ever be used.)

					String classprop = classPropertyPrefix + ent.entityName;
					if(strategies.containsKey(classprop)) {
						throw new Exception("Multiple class strategies defined for property " + ent.entityName);
					}

					if(strat.getBinner() == null) {
						if(!useElementFrom(strat, "usebinner", defaultPropertyName)) {
							throw new Exception("Property with null binner failed to use the one from " + defaultPropertyName);
						}
						System.err.println("Null binner in class strategy for property " + ent.entityName + " - will use binner from " + defaultPropertyName);
					}
					if(strat.getEvaluator() == null) {
						if(!useElementFrom(strat, "useevaluator", defaultPropertyName)) {
							throw new Exception("Property with null evaluator failed to use the one from " + defaultPropertyName);
						}
						System.err.println("Null evaluator in class strategy for property " + ent.entityName + " - will use evaluator " + defaultPropertyName);
					}
					if(strat.getValueType() == null) {
						if(!useElementFrom(strat, "usevaluetype", defaultPropertyName)) {
							throw new Exception("Property with null valuetype failed to use the one from " + defaultPropertyName);
						}
						System.err.println("Null valuetype in classstrategy for property " + ent.entityName + " - will use valuetype " + defaultPropertyName);
					}

					//create a new ArrayList (because it has to be in one, even if there's only one)
					ArrayList<FEStrategyBase> stratvec = new ArrayList<FEStrategyBase>();
					stratvec.add(strat);
					strategies.put(classprop, stratvec);
				}
			}

			nextStart += ent.offsetToContent+propertyExtent;
			if(nextStart >= configTokensList.size()) {
				done = true;
			}
		}

		return true;
	}


	//then call this after the accumulate. Applies the global or per-property time range to any property strategy
	//(except class strategies) that has a null time range currently.
	//also makes sure that none of the strategies' time ranges overlap the class timestamp.
	public boolean validateAfterAccumulation(C3POTimeRange globalRange, C3POFilterConfiguration filtconf, String classProperty, long classBinTime) throws Exception {
		//check to make sure there is a default strategy (or more)
		//actually... we want to be able to accumulate them, right?
		if(strategies == null || !strategies.containsKey(defaultPropertyName)) {
			throw new Exception("ERROR: no strategy given for " + defaultPropertyName);
		}

		//set the default strategy's time range to the global.
		System.err.println("Setting default strategies' time range to " + globalRange);
		for(int j=0;j<strategies.get(defaultPropertyName).size();j++) {
			strategies.get(defaultPropertyName).get(j).getBinner().setRange(globalRange);
		}

		//fill in time ranges
		//and FURTHER make sure that the class timestamp is after all the strategies' time ranges,
		//like after their start AND after their end (make sure they don't START after it!)
		//Also ok if it's equal to their end, because end is exclusive, yes?
		for(String prop:filtconf.getPropertiesInOrder()) {
			System.err.println("-- time range set checking property |" + prop + "|");
			//don't do it for any property that will use the default or for any class strategies.
			//1/17/14 I think this is the wrong call - we don't want hasClassStrategyForProperty here, we just want
			//hasStrategyForProperty, yes?
			//was if(hasClassStrategyForProperty(prop)) {
			if(hasStrategyForProperty(prop)) {

				//fetch per-prop time range for this property.
				C3POTimeRange theRange = filtconf.getTimeRangeForProperty(prop);

				//and if there isn't one, use global range.
				if(theRange == null) {
					theRange = globalRange;
				} else {
					//if any of its strategies uses some other property's binner and has its own time range, yell.
					for(int j=0;j<strategies.get(prop).size();j++) {
						if(strategies.get(prop).get(j).usesOtherPropertyBinner) {
							throw new Exception ("Property " + prop + " strategy " + j + " uses a different strategy's binner but has a per-property time range");
						}
					}
				}

				//make sure class timestamp is after the range (or = its end bc end is exclusive)
				if(classBinTime < theRange.getStartTime() || classBinTime < theRange.getEndTime()) {
					throw new Exception("Class bin timestamp " + C3POTimeRange.timeToTimestamp(classBinTime) + " overlapped by time range for property " + prop + ": " + theRange);
				}

				//spot where it broke on amazon machine: as if it had a class strategy for the property but that strategy was null.
				//actually strategies itself could be null here.
				if(strategies == null) {
					System.err.println("-- error: no feature extraction strategies are loaded!");
					System.exit(1);
				}
				if(strategies.get(prop) == null) {
					//OK...this is coming up for basicFEConfig because there IS a class strategy for diasabp but
					//there is no NORMAL strategy explicitly for it.
					System.err.println("-- error: strategy for " + prop + " exists but is null");
					System.exit(1);
				}
				for(int j=0;j<strategies.get(prop).size();j++) {
					//and only apply it where the time range is currently null.
					if(strategies.get(prop).get(j).getBinner().getRange() == null) {
						//System.err.println("Setting binner time range for property " + prop + " strategy " + j + " to " + theRange);
						strategies.get(prop).get(j).getBinner().setRange(theRange);
					}
				}
			} else {
				//property uses default strategy; yell if it has its own time range
				if(filtconf.getTimeRangeForProperty(prop) != null) {
					throw new Exception("Property " + prop + " uses default strategy but has a per-property time range");
				}

				//make sure class timestamp is after the range (or = its end bc end is exclusive)
				for(int j = 0;j<strategies.get(defaultPropertyName).size();j++) {
					C3POTimeRange theRange = strategies.get(defaultPropertyName).get(j).getBinner().getRange();
					if(classBinTime < theRange.getStartTime() || classBinTime < theRange.getEndTime()) {
						throw new Exception("Class bin timestamp " + C3POTimeRange.timeToTimestamp(classBinTime) + " overlapped by time range for property " + defaultPropertyName + ": " + theRange);
					}
				}

			}
		}

		//also sanity check that the property given as class is in the filter config with at least one
		//class property. It's ok if there's not a normal property strategy, it could use default.
		if(hasClassStrategyForProperty(classProperty)) {
			//TEST 1/23/14 TO AVOID THE TIME RANGE TRAMPLING KLUDGE I DID BEFORE 
			//HERE FORCE TIME RANGE FOR CLASS STRATEGY to be 0..class bin time+1 because the end is exclusive and we want to include class bin time.
			System.err.println("-- Setting class property time range 0.."+classBinTime + ", currently " + strategies.get(classPropertyPrefix+classProperty).get(0).getBinner().getRange());
			C3POTimeRange theRange = new C3POTimeRange(0,classBinTime+1);
			strategies.get(classPropertyPrefix+classProperty).get(0).getBinner().setRange(theRange);
		} else {
			throw new Exception("ERROR: no class strategy defined for property " + classProperty);
		}

		//AND check to see that the class timestamp falls within the time range for that strategy
		//not ok for it to be = to end time, because that's outside
		/* ACTUALLY let's not do this... makes a contradiction bt time ranges if you want to do usebinner
		 * we'll just understand that classes are special.
		C3POTimeRange classrange = getClassStrategyForProperty(classProperty).getBinner().getRange();
		if(classBinTime < classrange.getStartTime() || classBinTime >= classrange.getEndTime()) {
			throw new Exception("Class bin timestamp " + C3POTimeRange.timeToTimestamp(classBinTime) + " not in class strategy binner range " + classrange);
		}
		 */

		return true;
	}

	public TreeMap<String,ArrayList<FEStrategyBase>> getStrategies() {
		return strategies;
	}

	//TEST MAIN ============================================================================================
	public static void main(String[] args) {

		if(args.length < 2) {
			System.err.println("Usage: C3POFeatureExtractionConfiguration (config file) (class property)");
			System.exit(0);
		}

		try {
			//let's have this just pop open a config file and show the tokens first, then we'll get worrying about what we got
			//second pass: find all the {} blocks
			//third pass: have it try to isntantiate the strategy classes
			String theFile = args[0];
			System.err.println("About to tokenize: " + theFile);
			FEConfiguration conf = new FEConfiguration();

			//first test: just tokenize a file and print the tokens
			ArrayList<CFECToken> toks = conf.tokenizeFile(new File(theFile));
			System.err.println("Tokens from input file:");
			System.err.print("|");
			for(CFECToken tok:toks) System.err.print(tok + "|");
			System.err.println();
			//end first test

			//second test: call the parse function on it.
			System.err.println("About to parse: " + theFile + " with class property " + args[1]);
			if(conf.accumulateFromTextConfigFile(theFile,args[1]) == false) {
				System.err.println("Failed!"); 
			} else {
				System.err.println("Success!");
			}			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
